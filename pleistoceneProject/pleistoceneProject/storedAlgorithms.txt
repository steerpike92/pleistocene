double Air::filterSolarRadiation(double incidentSolarEnergyKJ) {

	//stratosphere absorbs solar radiation at a greater rate
	double ozoneBoost = 2;
	incidentSolarEnergyKJ = _stratosphere.filterSolarRadiation(incidentSolarEnergyKJ*ozoneBoost)/ozoneBoost;

	for (std::vector<GaseousMixture>::reverse_iterator &i = _troposphere.rbegin();i != _troposphere.rend(); ++i) {//reverse iterator
		incidentSolarEnergyKJ = i->filterSolarRadiation(incidentSolarEnergyKJ);
	}

	incidentSolarEnergyKJ = _boundaryLayer.filterSolarRadiation(incidentSolarEnergyKJ);

	return incidentSolarEnergyKJ;
}

double Air::filterAndComputeBackRadiation(double incidentInfraredEnergyKJ) {

	fillRadiationArrays(incidentInfraredEnergyKJ);

	_backRadiation = filterDownRadiationArray();
	_escapedRadiation = filterUpRadiationArray();

	return _backRadiation;
}

void Air::fillRadiationArrays(double incidentInfraredEnergyKJ) {

	//Step 0: 0 initialize radiation arrays
	for (int i = 0; i < _layerCount+2; i++) {
		_upRadiation[i] = 0.0;
		_downRadiation[i] = 0.0;
	}


	//EX (troposphere may be different number of layers)

	//index, layer

	// 0 -- surface		(downRadiation[0] = back radiation)(upRadiation[0] = 0)
	// 1 -- _boundaryLayer	(upRadiation[1] is from surface)
	// 2 -- _troposphere[0]
	// 3 -- _troposphere[1]
	// 4 -- _troposphere[2]
	// 5 -- _troposphere[3]
	// 6 -- _stratosphere	(downRadiation[6] = 0)
	// 7 -- space		(downRadiation[7] = 0)(upRadiation[7] escapes system)

	//Radiation arrays give the direction and KJ of energy INCIDENT upon THAT layer


	//Step 1: Fill radiaiton arrays with emitted energy
	_upRadiation[1] = incidentInfraredEnergyKJ;

	double emittedRadiation;

	int layerIndex = 1;

	//1.a boundary layer
	emittedRadiation = _boundaryLayer.emitInfrared();
	_upRadiation[layerIndex + 1] = emittedRadiation / 2.0;
	_downRadiation[layerIndex-1] = emittedRadiation / 2.0;//this radiation goes to surface
	layerIndex++;

	//1.b troposphere
	for (GaseousMixture &gasMix : _troposphere) {
		emittedRadiation = gasMix.emitInfrared();
		_upRadiation[layerIndex+1] = emittedRadiation / 2.0;
		_downRadiation[layerIndex-1] = emittedRadiation / 2.0;
		layerIndex++;
	}

	//1.c stratosphere
	emittedRadiation = _stratosphere.emitInfrared();
	_upRadiation[layerIndex+1] = emittedRadiation / 2.0;//this radiation goes to space
	_downRadiation[layerIndex-1] = emittedRadiation / 2.0;
}

double Air::filterUpRadiationArray() {
	/*std::cout << "\nupRad: ";
	for (int i = 0; i < _layerCount + 2; i++) {
		std::cout << int(_upRadiation[i])<<", ";
	}*/

	int layerIndex = 1;

	_upRadiation[layerIndex + 1] += _boundaryLayer.filterInfrared(_upRadiation[layerIndex]);//filter up to cell above
	layerIndex++;

	for (GaseousMixture &gasMix : _troposphere) {
		_upRadiation[layerIndex + 1] += gasMix.filterInfrared(_upRadiation[layerIndex]);//filter up to cell above
		layerIndex++;
	}
	//std::cout << "Before Stratosphere: " << int(_upRadiation[layerIndex]) << std::endl;
	_upRadiation[layerIndex+1] +=_stratosphere.filterInfrared(_upRadiation[layerIndex]);//escapes to space
	//std::cout << "After Stratosphere: " << int(_upRadiation[layerIndex+1]) << std::endl;

	return _upRadiation[layerIndex +1];
}

double Air::filterDownRadiationArray() {
	/*std::cout << "\ndownRad: ";
	for (int i = 0; i < _layerCount + 2; i++) {
		std::cout << int(_downRadiation[i]) << ", ";
	}*/

	int layerIndex = _layerCount-1;

	for (std::vector<GaseousMixture>::reverse_iterator &gasPtr = _troposphere.rbegin(); gasPtr != _troposphere.rend(); ++gasPtr) {//reverse iterator
		_downRadiation[layerIndex - 1] += gasPtr->filterInfrared(_downRadiation[layerIndex]);
		layerIndex--;
	}
	//std::cout << "Before Boundary: " << int(_downRadiation[layerIndex]) << std::endl;
	_downRadiation[layerIndex - 1] += _boundaryLayer.filterInfrared(_downRadiation[layerIndex]);//back to surface
	//std::cout << "After Boundary: " << int(_downRadiation[layerIndex-1]) << std::endl;

	return _downRadiation[0];
}




void Land::determineElevationType() {
	if (_elevation < climate::earth::landCutoff) {
		_elevationType = climate::earth::SUBMERGED;
		_elevationShader = abs(double(_elevation + 6*climate::earth::gaps)) / double(6*climate::earth::gaps);
		return;
	}
	if (_elevation <climate::earth::midCutoff) {
		_elevationType = climate::earth::LOW_LAND;
		_elevationShader = abs(0.6+ 2*double(climate::earth::gaps-_elevation) / double(5*climate::earth::gaps));
		return;
	}
	if (_elevation < climate::earth::highCutoff) {
		_elevationType = climate::earth::MID_LAND;
		_elevationShader = abs(0.6+ 2*double(2*climate::earth::gaps-_elevation) / double(5 * climate::earth::gaps));
		return;
	}

	_elevationType = climate::earth::HIGH_LAND;
	_elevationShader = abs(0.4 + 2*double(_elevation-2*climate::earth::gaps) / double(10 * climate::earth::gaps));
	return;
}




bool Land::draw(Graphics &graphics, std::vector<SDL_Rect> onScreenPositions, climate::DrawType drawType) {

	double solarShader = SolarRadiation::getRadiationShader(_solarFraction);

	double textureShader = solarShader*_elevationShader;
	textureShader = std::max(textureShader, 0.05);

	graphics.darkenTexture(_elevationTextures[_elevationType],textureShader);

	return graphics.blitSurface(_elevationTextures[_elevationType], NULL, onScreenPositions);
}

std::map<climate::earth::elevationType, std::string> Land::_elevationTextures;

void Land::setupTextures(Graphics &graphics) {

	//Elevation graphics
	_elevationTextures[climate::earth::SUBMERGED] = "../../content/simpleTerrain/midOcean.png";
	_elevationTextures[climate::earth::LOW_LAND] = "../../content/simpleTerrain/lowLand.png";
	_elevationTextures[climate::earth::MID_LAND] = "../../content/simpleTerrain/midLand.png";
	_elevationTextures[climate::earth::HIGH_LAND] = "../../content/simpleTerrain/highLand.png";

	//load graphics
	for (std::pair< climate::earth::elevationType, std::string> P : _elevationTextures) {
		graphics.loadImage(P.second);
	}


	//Terrain graphics
	//"../../content/simpleTerrain/lakeMod.png";
}


Water::Water(climate::water::BodyType waterType, double landElevation, double surfaceElevation, double localInitialTemperature) :
	_bodyType(waterType),
	_landElevation(landElevation),
	_surfaceElevation(surfaceElevation)
{

	_elevationShader = abs(double(_landElevation + 6 * climate::earth::gaps)) / double(6 * climate::earth::gaps);	

	using namespace elements;

	Element water = Element(VOLUME, WATER, 20);

	_waterSurface = LiquidMixture(water, localInitialTemperature);

}


bool Water::draw(Graphics & graphics, std::vector<SDL_Rect> onScreenPositions, climate::DrawType drawType)
{
	double solarShader = SolarRadiation::getRadiationShader(_solarFraction);

	double textureShader = solarShader*_elevationShader;
	textureShader = std::max(textureShader, 0.05);

	graphics.darkenTexture(_waterTextures[_bodyType], textureShader);

	return graphics.blitSurface(_waterTextures[_bodyType], NULL, onScreenPositions);
}